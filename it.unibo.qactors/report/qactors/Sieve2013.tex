\documentclass{../llncs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% package sillabazione italiana e uso lettere accentate
%%% \usepackage[latin1]{inputenc}
%%% \usepackage[english]{babel}
%%% \usepackage[T1]{fontenc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{url}
\usepackage{xspace}
\usepackage{makeidx}
\usepackage{hyperref}

\pagestyle{headings}

%%\makeatletter
\makeindex



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
%%% \usepackage{../manifest}
%%% \usepackage{graphicx}
\usepackage[UKenglish]{babel} % per la sillabazione inglese
%%% \usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{url}
\urldef{\mailsa}\path|{aaa,|
\urldef{\mailsb}\path|bbb,|
\urldef{\mailsc}\path|ccc, lncs}@springer.com|
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}
\usepackage{amssymb}    %%% by AN
\usepackage{fancyvrb}   %%% by AN
\usepackage{floatflt}   %%% by AN

\makeatother


%%%%%%%
 \newif\ifpdf
 \ifx\pdfoutput\undefined
 \pdffalse % we are not running PDFLaTeX
 \else
 \pdfoutput=1 % we are running PDFLaTeX
 \pdftrue
 \fi
%%%%%%%
 \ifpdf
 \usepackage[pdftex]{graphicx}
 \else
 \usepackage{graphicx}
 \fi
%%%%%%%%%%%%%%%
 \ifpdf
 \DeclareGraphicsExtensions{.pdf, .jpg, .tif}
 \else
 \DeclareGraphicsExtensions{.eps, .jpg}
 \fi
%%%%%%%%%%%%%%%

\oddsidemargin 0.0in
\evensidemargin 0.1in 
%
% Comments
%

\input{../MyStyle.sty}
%
% Comments
%
\newcommand{\todo}[1]{\bf{TODO:}\emph{#1}}


\begin{document}
\title{The Sieve of Eratosthenes in \contact{}}
\author{\xauthAN }
\institute{%
  \xunibo\\\xaddrCE, \xcityCE\\\email{antonio.natali@unibo.it}
}
\maketitle

\begin{abstract}
\footnotesize
This work presents the usage of the \contact{} system with reference to the definition of  dynamically (re)configurable distributed software systems, by assuming as a case-study a distributed implementation of the \emph{Sieve of Eratosthenes} algorithm.
 \end{abstract}


The repository \textit{Sieve2013.git} (at \texttt{137.204.107.21}) includes the following projects (in increasing order of complexity):

\begin{enumerate}
\item \textit{it.unibo.sieve.oo}:  A model of the sieve system based on core-objects defined during requirement analysis (see \xs{sieveeratoo}).

\medskip 
Artifacts: \textit{Interfaces} \texttt{IPrime}, \texttt{IFilter} etc.
\medskip 
\item \textit{it.unibo.sieveNoPipe}: The sieve system as a pipe of three (statically configured) subjects (that reuse the core-objects of \xs{sievedistr1}) and interact via message-passing.

\medskip 
Artifacts: \textit{Interfaces}  \texttt{INatural}, \texttt{IPrime extends INatural}, \texttt{OO reconfigure} operation
\medskip 
\item \textit{it.unibo.sieve.pipe}: A new version of the the sieve system in which the filter chain is implemented as a pipe of subjects interacting via message-passing (see \xs{sievedistr2}).

\medskip 
Artifacts: a new \texttt{reconfigure} operation that calls \texttt{updateKBandRun}
\medskip 

\item \textit{it.unibo.sieve.pipe.user}: A new sieve system that includes an \textit{user} that can ask for a prime number and stops the computation (see \xs{sieveUser}).

\medskip 
Artifacts: operations to check for the presence of messages, hidden within the \texttt{onMessage?} construct:
\medskip 
\begin{Verbatim} [fontsize=\footnotesize,  frame=single, label=check message operations] 
boolean checkForMsg( String receiver, String msgId, IPolicy policy  ) and 
boolean checkForSignal(String sender, String msgId, boolean mostRecent, IPolicy policy ) 
IMessage checkSignal( String sender, String msgId, boolean mostRecent  )
\end{Verbatim}

\medskip 

\item \textit{it.unibo.sieve.observer}: A sieve system that includes an \textit{observer} of the shared space that stops the computation (see \xs{sieveObserver}).

\medskip 
Artifacts: \texttt{Subject passive} and \texttt{LindaLike.register( java.util.Observer obj )}
\medskip 



\end{enumerate}
\sloppy
\tableofcontents
%%%\sloppy

\newpage
%=======================================================
\section{Introductionn}
\labelsec{intro}
%=======================================================
This work presents the usage of the \contact{} system with reference to the definition of  dynamically (re)configurable distributed software systems. The case-study is a distributed implementation of the algorithm known as \emph{Sieve of Eratosthenes} that finds the prime numbers.

An introduction to the  \contact{} system can be found in \cite{Nat2013a}. 
%A \contact{} specification is a model that defines the entities (called \emph{Subjects}) that compose the initial configuration of a software system and the high level communication patterns among these components, expressed with reference to a (open ended) set of different message types, e.g. \emph{signal, dispatch, invitation, request}.

%A system is described in \contact{} by considering two main dimensions: \emph{structure} and \emph{interaction}. The \emph{behavior} is actually not specified, since it can be better expressed in a conventional object oriented \texttt{GPL} like \java.

%------------------------------------------
\subsection{Overview}
\labelssec{overview}
%------------------------------------------

The repository \textit{sieve2013.git} (at \texttt{137.204.107.21}) includes the following projects (in increasing order of complexity):

\begin{enumerate}
\item \textit{it.unibo.sieve.oo}:  A model of the sieve system based on core-objects defined during requirement analysis (see \xs{sieveeratoo}).
\item \textit{it.unibo.sieveNoPipe}: The sieve system as a pipe of three (statically configured) subjects (that reuse the core-objects of \xs{sievedistr1}) and interact via message-passing.
\item \textit{it.unibo.sieve.pipe}: A new version of the the sieve system in which the filter chain is implemented as a pipe of subjects interacting via message-passing (see \xs{sievedistr2}).
\item \textit{it.unibo.sieve.pipe.user}: A new sieve system that includes an \textit{user} that can ask for a prime number and stops the computation (see \xs{sieveUser}).
\item \textit{it.unibo.sieve.observer}: A sieve system that includes an \textit{observer} of the shared space that stops the computation (see \xs{sieveObserver}).

\end{enumerate}

Worthwhile to note:

\begin{itemize}
\item Modelling of domain entities as conventional objects (see \xs{sieveeratoo})
\item Subject classes (see \xss{distr1behFilterN}))
\item Specifications of interactions involving classes (instead of instances) (see \xss{ladistr2})
\item Dynamic reconfiguration of \contact{} systems (see \xss{distr2reconfig})
\item Interaction operations with time-out (see \xs{sieveUser}))
\item Connection-based interactions in \contact{} (TODO)
\end{itemize}
%------------------------------------------
\subsection{The system 'Sieve of Eratosthenes'  }
\labelssec{sieveerat}
%------------------------------------------
The initial system configuration of the \emph{SieveSystem} is made of three elements: \emph{i)} a generator of natural numbers (named \texttt{intGen}) starting from \texttt{3}; \emph{ii)} a filter (named \texttt{filter2}) that eliminates all the natural numbers divisible for \texttt{2} and \emph{iii)} a collector of the prime numbers (named \texttt{sieve}). There is also an entity (named \texttt{user}) interested to the results of the computation.

The behavior of the system can be informally described as follows.
\begin{quotation}
\footnotesize
\noindent
\textit{\textbf{The Sieve of Eratosthenes.}}
When \texttt{filter2} receives from \texttt{intGen} a number not divisible by \texttt{2} (i.e. \texttt{3}), it sends such a number to the \texttt{sieve} that stores it as a prime number. Moreover, \texttt{filter2} reconfigures the system by creating a new filter (named \texttt{filter3}) that will eliminate from the system all the numbers divisible by \texttt{3}. The new filter \texttt{filter3} works as a new element of the system inserted between \texttt{filter2} and the \texttt{sieve}. In this way, the next number that reaches the \texttt{sieve} will be \texttt{5} and a filter for it (\texttt{filter5}) will be inserted between the filter for \texttt{3} and the \texttt{sieve}. 

The user could ask the sieve for the element of a given position in the ordered sequence of prime numbers.

\noindent
%%\textit{\textbf{End}}
\normalsize
\end{quotation}

\newpage
%==============================================
\section{An object-based model of the sieve system}
\labelsec{sieveeratoo}
%==============================================
In order to better understand how a distributed (heterogeneous) system can be built by (re)using conventional object models defined during the requirement or the problem analysis, let us briefly introduce a pure object oriented (oo) version of the system.
%
The workflow is summarized as follows:
\begin{enumerate}
\item REQUIREMENT/PROBLEM ANALYSIS: Model of each domain entity as a "pure" data objects described by an core-interface associated with a proper test-plan.

\medskip 
\begin{Verbatim} [fontsize=\footnotesize,  frame=single, label=core-interfaces]
public interface IPrime {
	public String getRep();
	public String getProloglikeRep(); //returns int( n )  
	public int getAsInt();
}
public interface IIntGen {
 	public int genNextInt(); 	
}
public interface IFilter  {
	public IPrime getMyPrime();
	public boolean handleNextInt(int v); //returns true if 'captured' by the filter
}
public interface ISieve {
	public void newPrime( IPrime v );
	public int getNumOfPrimes();
	public IPrime getPrimeAtPos(int i);
}
\end{Verbatim}

The test-plan is left to the reader.

\item DESIGN: Model of each domain entity as an object that implements a core-interface and interacts with other objects

\medskip
\begin{Verbatim} [fontsize=\footnotesize,  frame=single, label= interfaces of the domain entities as objects]
public interface IEntity { public void doJob();}
public interface IPrimeObj extends IPrime, IEntity{} 
public interface IIntGenObj extends IIntGen, IEntity{}
public interface IFilterObj extends IFilter, IEntity{}
public interface ISieveObj extends ISieve, IEntity{}
\end{Verbatim}

\item DESIGN: (Model of) a system-configuration object

\medskip
\begin{Verbatim} [fontsize=\footnotesize,  frame=single, label=configuration operations]
	protected void createElements(){
 		sieve = new SieveObj("sieve");
		filter2 = new FilterObj( "filter2", new PrimeObj("prime2",2),sieve);
		intGen = new IntGenObj("intGen",filter2);
	}
	protected void start(){ intGen.doJob();	}	
\end{Verbatim}
Each object is configured (i.e. connected with other objects) at creation time.
\end{enumerate}

%------------------------------------
\subsection{OO (domain) model}
\labelssec{oosievem}
%------------------------------------

The behavior of each domain object is defined by applying proper design patterns. For example:


\subsubsection{FilterCore and FilterObj.\\}
\labelssec{oodecorator}

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=FilterCore]
public class FilterCore implements IFilter{
protected IPrime myPrime;
	public FilterCore(IPrime myPrime){ this.myPrime = myPrime;	}	
	@Override
	public boolean handleNextInt(int v) { return (v % myPrime.getAsInt())  == 0 ; 	}
	@Override
	public IPrime getMyPrime() { return myPrime;	}
}
\end{Verbatim}



\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=FilterObj (as a \textit{decorator} \cite{gof94} of FilterCore)]
package it.unibo.sieve.oo.impl;
import it.unibo.is.interfaces.IOutputView;
import it.unibo.sieve.oo.core.*;
import it.unibo.sieve.oo.interfaces.*;
public class FilterObj extends Entity implements IFilterObj{
protected IFilter filterCore ;
protected ISieve sieve ;
protected IFilterObj nextFilter ;
	public FilterObj(String name, IPrime prime, IOutputView outView ){
		super(name,outView);
		filterCore = new FilterCore(prime);
	}	
	public FilterObj(String name, IPrime prime, ISieve sieve ){
		super(name,null);
		this.sieve 	= sieve;
		filterCore = new FilterCore(prime);
	}	
	public FilterObj(String name,IPrime prime, IFilterObj filter){
		super(name,null);
		nextFilter 	= filter;
		filterCore = new FilterCore(prime);
	}	
	@Override
	public boolean handleNextInt(int v) {
	boolean todiscard = filterCore.handleNextInt(v);
		if(  todiscard ) {
			showMsg( "		DISCARDS: "  +  v );
			return true;
		}
		sendIntToNext(v);
		return false;
	}
	@Override
	public IPrime getMyPrime() { return filterCore.getMyPrime(); }
	@Override
	public void doJob(){}  	
	protected void sendIntToNext(int curVal) {
		if (nextFilter != null) {
			showMsg("		DELEGATES TO NEXT: " + curVal);
			nextFilter.handleNextInt(curVal);
			return;
		}
		// FOUND NEW PRIME
		IPrime vp = new PrimeObj("prime" + curVal, curVal);
		reconfigure(vp);
		sendNewprimeTosieve(vp);
	}	
	protected void reconfigure(IPrime vp){
		showMsg("	*** NEW PRIME: " + vp.getRep());
		nextFilter = createAnotherFilter(vp);		
	}
	protected IFilterObj createAnotherFilter(IPrime vp) {
		return new FilterObj("filter" + vp.getRep(), vp, sieve);
	}
	protected void sendNewprimeTosieve(IPrime vp) {
		sieve.newPrime(vp);
	}
}
\end{Verbatim}

\newpage
%==============================================
\section{From the oo sieve system to a first distributed system}
\labelsec{sievedistr1}
%==============================================
Let us define here the sieve system as a pipe of subjects interacting by message-passing. Each subject is conceived as a new decorator of a core object introduced in \xs{sieveeratoo}. 
The filter chain is designed and implemented as a chain of objects interacting via method calls, as done in \xss{oosievem}.
No user subject is introduced; the computation terminates when \texttt{intGen} generates the  number \texttt{0}\footnote{i.e. the message content \texttt{natural(0)}, see \xss{applmc}}.

%------------------------------------
\subsection{Logic architecture: structure and interaction}
\labelssec{ladistr1}
%------------------------------------
The following "code" is a model, expressed in the custom language/metamodel called \contact{} \cite{Nat2013a}. This model defines the \textit{initial configuration} of the application as a system composed of three active entities (the \textit{subjects}) that interact via message-passing.

\begin{Verbatim} [fontsize=\footnotesize,  frame=single, label=sieveNoPipeWithObj.contact ]
ContactSystem sieveNoPipeWithObj   ;    
Subject class FilterN  ;   
Subject intGen   -w;           
Subject sieve    -w;  
Subject filter2 inherits FilterN    -w;       
            
Dispatch nextInt ;    
Invitation newPrime ; 

sendIntToFilter2 : intGen forward  nextInt to filter2 ;
recFilter2Int :  filter2 serve nextInt ;

sendPrimeToSieve : FilterN ask newPrime to sieve ;	//CLASS-LEVEL INTERACTION SPEC
recNewprime : sieve accept newPrime ;
\end{Verbatim}

The subject \texttt{filter2} is defined as a specialized version of a class of subjects named \texttt{FilterN}. Any object of class \texttt{FilterN} is able to \textit{ask} the invitation \texttt{newPrime} to the \texttt{sieve} subject, while only the subject \texttt{filter2} is able to receive the dispatch \texttt{nextInt} (sent from the \texttt{intGen} subject).

%------------------------------------
\subsubsection{Modelling application message content.\\}
\labelssec{applmc1}
%------------------------------------
The current version of \contact{} (\texttt{1.6.12}) does not allow to formally specify the application content of messages \footnote{A proposal to achieve this goal could be studied by the reader.}.  However, in order to interact, two entities must agree on the format of the message exchanged at application level.
We\footnote{The reader should evaluate if this specification is introduced in some analysis phase or in a design phase.} state here that:
\begin{itemize}
\item The content of the \textit{dispatch} \texttt{nextInt} is modelled as a Prolog structured \texttt{Term} of the form \texttt{natural(n)}.
\item The content of the \textit{invitation} \texttt{newPrime} is modelled as a Prolog structured \texttt{Term} of the form \texttt{prime(n)}.
\end{itemize}

As a consequence, we introduce a proper extension to the domain model of \xs{sieveeratoo}.

%------------------------------------
\subsection{Re-factoring the models of the domain data}
\labelssec{newdata1}
%------------------------------------

The new model of the domain data is now re-defined by introducing the concept of natural number and the idea that each data-entity must provide one or more operations that build a proper string-based representation of that entity :

\begin{Verbatim} [fontsize=\footnotesize,  frame=single, label=New core-interfaces]
public interface IPrime extends INatural{}

public interface INatural {
	public String getRep(); //a default rep for output purposes
 	public int getAsInt();
 	public String getProloglikeRep(); //returns natural( n )
}
public interface IIntGen {
 	public INatural genNextInt(); 	
} 
\end{Verbatim}

The new test-plan is left to the reader. 

For each interface we introduce an implementation class that provides (if it is the case) a set of \textit{\textbf{factory methods}} \cite{gof94} in order to facilitate the work of the application designer. Moreover, a \textit{\textbf{class invariant}} is introduced, when appropriate.

\subsubsection{Natural numbers.\\}

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=The class Natural]
public class Natural implements INatural {
	protected int v;

	public static INatural create(int v) throws Exception {
		return new Natural(v);
	}

	public static INatural parsePrologRep(String rep) throws Exception {
	//ASSUMPTION: rep = natural( n ) (as built by getProloglikeRep)
		return new Natural(parsePrologRepToInt(rep));
	}

	public static int parsePrologRepToInt(String rep) throws Exception {
	//rep = natural( n ) (built by getProloglikeRep)
		Struct rt = (Struct) Term.createTerm(rep);
		int val = Integer.parseInt("" + rt.getArg(0));
		return val;
	}

	public Natural(int v) throws Exception {
		invariant(v);
		this.v = v;
	}

	@Override
	public String getRep() {
		return "" + v;
	}

	@Override
	public int getAsInt() {
		return v;
	}

	@Override
	public String getProloglikeRep() {
		return "natural(" + v + ")";
	}

	protected void invariant(int v) throws Exception {
		if (v < 0)
			throw new Exception("Natural creation error");
	}
}
}
\end{Verbatim}

\subsubsection{Prime numbers.\\}

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=Prime numbers]
public class PrimeCore implements IPrime {
	protected int v;

	public static IPrime create(int v) throws Exception {
		return new PrimeCore(v);
	}

	public static IPrime create(String prologRep) throws Exception {
		// ASSUMPTION: prologRep = prime( n ) (as built by getProloglikeRep)
		return new PrimeCore(Natural.parsePrologRepToInt(prologRep));
	}

	public PrimeCore(int v) throws Exception {
		this.v = v;
		invariant(v);
	}

	@Override
	public String getRep() {
		return "" + v;
	}

	@Override
	public int getAsInt() {
		return v;
	}

	@Override
	public String getProloglikeRep() {
		return "prime(" + v + ")";
	}

	protected void invariant(int v) throws Exception {
		if (v < 0)
			throw new Exception("PrimeCore creation error");
		// check that v is divisible for 1 and itself only (TODO)
	}
}
\end{Verbatim} 
 
\subsubsection{FilterCore.\\}

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=FilterCore]
public class FilterCore implements IFilter {
	protected IPrime myPrime;

	public static IFilter create(IPrime myPrime) {
		return new FilterCore(myPrime);
	}

	public static IFilter create(int v) throws Exception {
		return new FilterCore(new PrimeCore(v));
	}

	public FilterCore(IPrime myPrime) {
		this.myPrime = myPrime;
	}

	@Override
	public boolean handleNextInt(int v) {
		return (v % myPrime.getAsInt()) == 0;
	}

	@Override
	public IPrime getMyPrime() {
		return myPrime;
	}
}
\end{Verbatim} 

\subsubsection{IntGenCore.\\}

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=IntGenCore ]
public class IntGenCore implements IIntGen {
	protected int n = 3;

	public static IIntGen create() {
		return new IntGenCore();
	}

	@Override
	public INatural genNextInt() {
		try {
			return new Natural(n++);
		} catch (Exception e) {
			return null;
		}
	}
}
\end{Verbatim}



%------------------------------------
\subsection{The first prototype (integration plan)}
\labelssec{distr1firstproto}
%------------------------------------
While waiting for a proper extension of our custom meta-model related to message contents, we introduce here some comment in the interaction section of the model of \xss{ladistr1}, in order to recall the structure of the contents of the messages required at application level.
%
We also introduce the specification of \textit{contexts} and network protocols, in order to allow the testing in a true distributed environment.

\medskip 
\begin{Verbatim} [fontsize=\footnotesize,  frame=single, label=sieveNoPipeWithObj.contact ]
ContactSystem sieveNoPipeWithObj   ; 
Context ctxIntGen -w;
Context ctxFilters -w;
Context ctxSieve -w;
Context ctxTesting  ;
   
Subject class FilterN  ;   
Subject intGen context ctxTesting  -w;           
Subject sieve  context ctxTesting  -w;  
Subject filter2 inherits FilterN  context ctxTesting  -w;       
            
Dispatch nextInt ;    
Invitation newPrime ; 

sendIntToFilter2 : intGen forward  nextInt to filter2 ; //nextInt content -> natural(n)
recFilter2Int :  filter2 serve nextInt support=TCP [host="localhost" port=8010];

sendPrimeToSieve : FilterN ask newPrime to sieve ;	//newPrime content -> prime(n)
recNewprime : sieve accept newPrime support=TCP [host="localhost" port=8020];
\end{Verbatim}

The logic architecture defined by this \contact{} model can lead to a \textit{\textbf{work plan}} in which each context can be designed, developed and tested by a different group of workers that can use this model as their common project (cognitive) map. Before starting the work in parallel, the software development team should complete the specification with the logic behavior for each subject, in order to fully specify the required interaction among the subjects.

%------------------------------------
\subsection{Behavior of the subject intGen}
\labelssec{behintGen}
%------------------------------------

The subject \texttt{intGen} is conceived as a new decorator of the object \texttt{intGenCore} introduced in \xss{newdata1}  that enables such an object to interact with the subject \texttt{filter2} by forwarding to it a message of type \texttt{nextInt} with content \texttt{natural(n)}.  

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=BehaviorOf intGen ] 
BehaviorOf intGen { 
var it.unibo.sieve.oo.interfaces.IIntGen intGenCore = null 
var it.unibo.sieve.oo.interfaces.INatural zero = null
var it.unibo.sieve.oo.interfaces.INatural n = null
var nAsInt = 0
var int maxN = 22
  	
 state  initGeninit  initial onException intGenError
	println( " START " 	)     
	set intGenCore = call it.unibo.sieve.oo.core.IntGenCore.create()
	set zero = call it.unibo.sieve.oo.core.Natural.create( const.0 )  
	set n = zero
	goToState genInt
 endstate 	 	   
 state  genInt  
	set n = call intGenCore.genNextInt()  
	set nAsInt = call n.getAsInt()
	println( "genInt | n=" + nAsInt  )
	doOut sendIntToFilter2( call n.getProloglikeRep() )		
	if{ nAsInt > maxN } { goToState intGenEnd }   
	goToState genInt  
 endstate 		
 state intGenEnd
	doOut sendIntToFilter2( call zero.getProloglikeRep() )
	transitToEnd
 endstate
 state intGenError
 	println( "Error " + code.curException)
	transitToEnd
 endstate
 }
\end{Verbatim}

%------------------------------------
\subsection{Behavior of the subject sieve}
\labelssec{behsieve}
%------------------------------------
The subject \texttt{sieve} receives an invitation of type \texttt{newPrime} with content \texttt{prime(n)} and stores the new prime (operation \texttt{storePrime}) in a local data structure.

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=BehaviorOf sieve ] 
BehaviorOf sieve {
var msg = ""	
var it.unibo.sieve.oo.interfaces.IPrime curPrime
   
 action void storePrime(it.unibo.sieve.oo.interfaces.IPrime vp)
 		
 state initSieve initial
	println( "START "  	)
	onMessage newPrime transitTo handleNewPrime
 endstate  	 	
 state handleNewPrime onException sieveError
	set msg = code.curInputMsgContent		//msg -> prime(n)
	if{  msg.contains("0") } { goToState sieveEnd }
	set curPrime = call it.unibo.sieve.oo.core.PrimeCore.create(msg)  
	println( "received " + msg ) //msg -> prime(n)
	exec storePrime( curPrime )
	onMessage newPrime transitTo handleNewPrime
 endstate	 	
 state sieveEnd 
	println( "END")
	transitToEnd   	
 endstate
 state sieveError
	println( "Error " + code.curException)
	transitToEnd   	
 endstate   
}
\end{Verbatim}

%------------------------------------
\subsection{Behavior of the subject filter2}
\labelssec{distr1behFilter2}
%------------------------------------
The subject \texttt{filter2} is conceived as a new decorator \cite{gof94} of objects of class \texttt{FilterCore} introduced in \xss{oosievem}  that enables core-objects to interact via message-passing with the subjects \texttt{intGen} and \texttt{sieve}. 
%
\texttt{filter2} models the behavior of a subject that: \textit{i)} receives a dispatch of type \texttt{nextInt} with content \texttt{natural(n)} and then \textit{ii)} does nothing if the recived number is divisible by \texttt{2} otherwise \textit{iii)} forwards the message (and the work) to (if this exists) the next filter object; if there is no other filter in the chain, \textit{iv)} it sends the received number as a new prime to the \texttt{sieve}, creates a new filter object and reconfigures the system by adding this new filter as its next filter of a object chain.

Most of the behavior of \texttt{filter2}  is defined in the class \texttt{filterN} by a set of inherited operations (see also \xss{distr1behFilterN}):

\begin{itemize}
\item \texttt{ void  handleNextValue(String applMsg) //applMsg = natural(n) }\\
\noindent
Main job of a filter. If the \texttt{applMsg} is \texttt{natural(0)}, it sets to \texttt{true} a boolean variable \texttt{stop}; otherwise it checks (by using the \texttt{filterCore}) if the number must be discarded and if not it calls \textit{sendIntToNext}.
\medskip 
\item \texttt{ void sendIntToNext(String applMsg) //applMsg = natural(n) }\\
\noindent
If there is a \texttt{nextFilter} in the chain, it calls the \texttt{handleNextValue} operation of this object. Otherwise (if \texttt{not stop}) it reconfigures the system (by calling the \texttt{reconfigure} operation) and sends the new prime (or the \texttt{natural(0)} \texttt{if stop}) to the \texttt{sieve}.
\medskip 
\item \texttt{ void reconfigure( )  }\\
\noindent
Reconfigures the system by creating a new prime and a new filter for it (that becomes it \texttt{nextFilter} in the object chain).
\end{itemize}

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=BehaviorOf filter2 ] 
BehaviorOf filter2 { 
var curValue = -1
 state  initFilter2  initial onException filter2Error
	set myfilterCore = call it.unibo.sieve.oo.core.FilterCore.create( const.2 );  
	println( "START " + myName	)
	onMessage nextInt transitTo filter2HandleInt 
 endstate 	  	
 state  filter2HandleInt onException filter2Error
	println( "received " + code.curInputMsg )	//curInputMsg -> natural(n)
	exec handleNextValue( code.curInputMsgContent )  //inherited : calls a method chain
	set curValue = code.curInt
	if{ curValue == 0 } { goToState filter2End }
	onMessage nextInt transitTo filter2HandleInt
 endstate 		
 state filter2End
	showMsg("END")
	transitToEnd
 endstate
 state filter2Error
	showMsg("Error " + code.curException  ) 
	transitToEnd
 endstate
}
\end{Verbatim}

%------------------------------------
\subsection{Behavior of the subject class FilterN}
\labelssec{distr1behFilterN}
%------------------------------------
The subject class \texttt{FilterN} defines a set of operations that realize the behavior of each filter in the object chain, i.e.:  \textit{i)} receive a dispatch of type \texttt{nextInt} with content \texttt{natural(n)} and then handle the received value by calling the \texttt{handleNextValue} operation. Since the filter chain is made of conventional ovjects, and the message-receive phase has been already described (and implemented) by the specialized subject \texttt{filter2} (see \xss{distr1behFilter2}), the state-machine defined within the \texttt{FilterN} specification is never executed.

%%\textit{ii)} discards it if divisible or \textit{iii)} delegate the work to the next filter object, if this exists or \textit{iv)} creates a new filter object and sends a new prime to the \texttt{sieve}.

 
\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=BehaviorOf FilterN ] 
BehaviorOf FilterN {    
 var it.unibo.sieve.oo.interfaces.IFilter myfilterCore  = null
 var it.unibo.sieve.oo.interfaces.IFilter newfilterCore   = null 	
 var it.unibo.contact.sievePipeWithObj.FilterN newfilter = null 
 var it.unibo.is.interfaces.IBasicEnvAwt myEnv	= null
 val withGui = true 	//CONFIGURATION; if true create a new GUI for each filter
 var myName = "" 
 var int curInt = 0
 var String newFilterName = null
 var boolean stop = false
 var it.unibo.sieve.oo.interfaces.IPrime curfNprime = null
   	
 //Used to inject a filter in (re)configuration (see createAnotherFilter)
 operation void setFilterCore( it.unibo.sieve.oo.interfaces.IFilter fcore){
	set myfilterCore = code.fcore
 }
  
 //Called by filter2 and by any filter in the chain   
 operation void handleNextValue(String applMsg){ 	//applMsg = natural(n)
	set curInt = call it.unibo.sieve.oo.core.Natural.parsePrologRepToInt(  code.applMsg  )
	if{ curInt == 0 }{	//stop the work
		set stop = const.true ;
		exec sendIntToNext( code.applMsg );
		{ return }
	}
	if{ myfilterCore.handleNextInt(curInt) } { 
		println( "		DISCARDS: "  +  curInt );
		{ return }
	}
	exec sendIntToNext( code.applMsg )
 }    
 /*
 * DELEGATE THE WORK to the next filter in the chain
 */
 operation void sendIntToNext(String applMsg){		//applMsg = natural(n)	
	if{ nextFilter != null }{ 
		//println( "		DELEGATES TO NEXT: "  +  code.curInt );			
		call nextFilter.handleNextValue(code.applMsg);
		if{ stop } {showMsg("END DETECTED") };
		{ return }
	}   
	if{ ! stop } {
		//NEW PRIME FOUND  
		set curfNprime = call it.unibo.sieve.oo.core.PrimeCore.create( code.applMsg );
		exec  reconfigure() ;
		exec sendValToSieve( call curfNprime.getProloglikeRep() );
		{return}
	}	 
	//stop => simply forward the natural to the sieve
	showMsg("END THE PROCESS")
	exec sendValToSieve( code.applMsg )
 }     
 operation void sendValToSieve ( String m ){
    	doOutIn sendPrimeToSieve( code.m )
    	acquireAckFor newPrime
    	showMsg("ack --> " + code.curReply)
 }
 /*
 * RECONFIGURE THE OBJECT FILTER CHAIN
 */
  operation void reconfigure(){
	//INSERT A NEW FILTER IN THE FILTER-OBJECT CHAIN  
	exec createAnotherFilter(  curfNprime ) 		
 }
 /*
 * CREATE A NEW FILTER OBJECT
 */
  operation void createAnotherFilter( it.unibo.sieve.oo.interfaces.IPrime prime ){
	set newFilterName = "filter" + curInt
	set nextFilter =  eval new it.unibo.contact.sievePipeWithObj.FilterN( newFilterName ) 
	call nextFilter.setEnv(code.env)	//calls initGui()  		
	set newfilterCore = call it.unibo.sieve.oo.core.FilterCore.create( code.prime );
	call nextFilter.setFilterCore( newfilterCore )  //Inject the filter core for the prime		
	println( "CREATED new filter obj for prime=" + curInt + " " + newFilterName )
 }   
//----------------------------------------------------------------     
 state  initFilter  initial
	println( "NEVER HERE since all the wirk is done by filter2"  	)
	transitToEnd
 endstate 
\end{Verbatim}


%----------------------------------------------------
\subsection{Dynamic creation of objects}
%----------------------------------------------------
The operation \textit{createAnotherFilter} of  \texttt{FilterN} creates a new instance of the class \texttt{FilterN} and then (following the same code pattern of the configuration code in the generated class \texttt{SieveSystemMain.java}) it injects in the new instance  the value of the associated prime number. 

The operation  \texttt{call newfilter.setEnv(code.env)} injects in the instance the same environment of the instance that creates it (\texttt{filter2} in this case). However, the application designer can associate a new environment to the created instance by overloading the \texttt{initGui} method:

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label= FilterN.java: create a new GUI ]
public class FilterN extends FilterNSupport{
protected static int port = 8098;
	public FilterN(String name) throws Exception {
		super(name);
  	}	
	public static FilterN create(String name) throws Exception{
		return new FilterN(name);
 	}
	protected void initGui(){
		if( ! withGui ) return ;
	    env = new EnvFrame( getName(), this, Color.green, Color.black );
	    env.init();
	    env.writeOnStatusBar(getName() + " | IntGenSupport working ... ",14);
	    view = env.getOutputView();
 	 }
}
\end{Verbatim} 
 
\newpage
%==============================================
\section{Towards a (full) distributed sieve system}
\labelsec{sievedistr2}
%==============================================
Let us define here a new version of the the sieve system as a pipe of subjects in which the filter chain is implemented as a pipe of subjects interacting via message-passing, instead of a chain of objects interacting via nethod calls, as done in \xss{oosievem} and \xs{sievedistr1}.
No user subject is introduced; the computation terminates when \texttt{intGen} generates the number \texttt{0}.

%------------------------------------
\subsection{Logic architecture: structure and interaction}
\labelssec{ladistr2}
%------------------------------------
The following  model, expressed in the custom language/metamodel \contact{} \cite{Nat2013a}, defines the \textit{initial configuration} of the application as done in \xss{ladistr1} with  some important extension marked with \texttt{(***)}.

\begin{Verbatim} [fontsize=\footnotesize,  frame=single, label=sieveNoPipeWithObj.contact ]
ContactSystem sieveNoPipeWithObj   ;    
Subject class FilterN  ;   
Subject intGen   -w;           
Subject sieve    -w;  
Subject filter2 inherits FilterN    -w;       
            
Dispatch nextInt ;    
Invitation newPrime ; 

sendIntToFilter2 : intGen forward  nextInt to filter2; 
recFilter2Int :  filter2 serve nextInt ; 
				//nextInt content->natural(n)
sendIntToFilterN : FilterN forward  nextInt to FilterN;// (1) (***)CLASS-LEVEL INTERACTION SPEC  
recFilterNInt : FilterN serve nextInt;//(2) (***)CLASS-LEVEL INTERACTION SPEC  

sendPrimeToSieve : FilterN ask newPrime to sieve;//(3)CLASS-LEVEL INTERACTION SPEC 
recNewprime : sieve accept newPrime support=TCP [host="localhost" port=8020];  
				//newPrime content->prime(n)
\end{Verbatim}

Now the model states that any object of class \texttt{FilterN} is able:
\begin{itemize}
\item \texttt{(1)} to forward the dispatch \texttt{nextInt} to another (dynamically created) filter;
\item \texttt{(2)} to serve the dispatch \texttt{nextInt}, sent by \texttt{intGen} or another, (dynamically created) filter;
\item \texttt{(3)} (as in \xss{ladistr1}): to \textit{ask} the invitation \texttt{newPrime} to the \texttt{sieve} subject;
\end{itemize}

Note that, at point \texttt{(1)}, no concrete destination is specified, but only the fact that it must belong to the \texttt{FilterN} class. This means that the \ide{} must generate a send support operation (whose signature is in this case \\
 \texttt{hl\_FilterN\_forward\_nextInt\_FilterN( String M, String destName )}) \\
 that includes an argument (\texttt{destName}) to be set by the application designer with the name of the concrete destination subject (see the operation \texttt{sendIntToNext} in \xss{distr2behFilterN}).
 
Moreover, at point  \texttt{(2)}, no protocol support is specified: in fact such a specification has no-sense (although technically possible) at class level, since it is meaningful only at subject-instance level. This means that some extra informatio must be given by the application designer when a new subject is created (see the operation \texttt{updateKBAndRun} in \xss{distr2behFilterN}).

%------------------------------------
\subsection{The first prototype (integration plan)}
\labelssec{distr2firstproto}
%------------------------------------

The work-plan of \xss{distr1firstproto} is still valid here, with the difference that the group of workers devoted to the design and development of \texttt{filter2} and \texttt{FilterN} must perform a more complex job than before.


%------------------------------------
\subsection{Behavior of the subject intGen}
\labelssec{distr2behintGen}
%------------------------------------
The behavior model of the subject \texttt{intGen} does not change with respect to \xss{behintGen}.

 
%------------------------------------
\subsection{Behavior of the subject sieve}
\labelssec{distr2behsieve}
%------------------------------------
The behavior model of the subject \texttt{sieve} does not change with respect to \xss{behintGen}.

%------------------------------------
\subsection{Behavior of the subject filter2}
\labelssec{distr2behFilter2}
%------------------------------------
The behavior model of the subject \texttt{filter2} is now different from that of \xss{behintGen}, since \texttt{filter2} now works like any other instance of \texttt{FilterN}. Thus the model now states that  \texttt{filter2} simply initializes its core and then inherits its behavior from the state machine defined by \texttt{FilterN}.

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=BehaviorOf filter2 ] 
BehaviorOf filter2 {     
 state  initFilter2  initial onException filter2Error
	set myfilterCore = call it.unibo.sieve.oo.core.FilterCore.create( const.2 );  
	println( "START " + myName	)
	call inheritedBehavior()
	goToState filter2End
 endstate 	  	
 state filter2End
	showMsg("END")
	transitToEnd
 endstate
 state filter2Error
	showMsg("Error " + code.curException  ) 
	transitToEnd
 endstate
}
\end{Verbatim}

%------------------------------------
\subsection{Behavior of the subject class FilterN}
\labelssec{distr2behFilterN}
%------------------------------------
As before (see \xss{distr1behFilterN}) the subject class \texttt{FilterN} defines a set of operations that realize the behavior of each filter, with the difference that now we have to design and build a subject pipe in which subjects interact via the \texttt{nextInt} dispatch.
%
Thanks to the software organization introduced in \xss{distr1behFilterN} the modification of the behavior model can be limited to the \textit{reconfigure} operation.

However, differently from \xss{distr1behFilterN}, the class \texttt{FilterN} must now specify the state machine that defines the behavior of all the (statically and dynamically created) filter subjects.

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=The FilterN state-machine] 
BehaviorOf FilterN {    
...    
//(***) RECEIVE AND HANDLE LOOP 
 state  initFilter  initial onException filterNError
	showMsg( "START " + myName	)
	onMessage nextInt transitTo filterNHandleInt   
 endstate 	 
 state  filterNHandleInt onException filterNError
	showMsg( "received " + code.curInputMsg )	//curInputMsg -> natural(n)
	exec handleNextValue( code.curInputMsgContent )    
	if{ curInt == 0 } { goToState filterNEnd }
	onMessage nextInt transitTo filterNHandleInt
 endstate 		
 state  filterNEnd
	showMsg( "END "  ) 
	transitToEnd
 endstate 	
 state  filterNError
	showMsg( "Error " + code.curException  ) 
	transitToEnd
 endstate    
\end{Verbatim}

%------------------------------------
\subsection{Dynamic reconfiguration of \contact{} systems }
\labelssec{distr2reconfig}
%------------------------------------
In order to dynamically extend a (working)  \contact{} system with other subjects, we have to execute at application level operations that are automatically generated by the \ide{} within the system-configuration class:

\begin{enumerate}
\item Create a new subject.
\item Update the run time knowledge base of the system with information useful to implement the communications patterns of that subject.
\item Start the new subject.
\end{enumerate}

In our case, the \textit{createAnotherFilter} operation of \xss{distr1behFilterN} can be reused to perform the step \texttt{1}, while the steps \texttt{2} and \texttt{3} are delegated by a new operation called \textit{updateKBAndRun}. Thus, the reconfiguration of the filter pipe can now be expressed as follows:

\begin{Verbatim} [fontsize=\scriptsize,  frame=single, label=The new recoinfigure oiperation ] 
BehaviorOf FilterN {    
...    
 action int getPortNum() 
	
 operation void reconfigure(){
	//INSERT A NEW FILTER IN THE FILTER-SUBJECT CHAIN  
	exec createAnotherFilter(  curfNprime ) 		
	exec updateKBAndRun(   )		// (***) UPDATE THE KB and RUN THE NEW FILTER
 }     
 operation void updateKBAndRun(   ){ 
	//UPDATE THE Run-Time Knowledge Base
	set nport =  exec getPortNum()
	println( "****************** reconfigureAndRun *********************** "  + nport  )
	call RunTimeKb.addSubject("TCP" , newFilterName , "nextInt", "localhost", nport );    
	//RUN THE SUBJECT	
 	call nextFilter.start()
 }    
\end{Verbatim}

The action \texttt{getPortNum} (to be defined by the application designer) returns an integer used as input-port of the new subject for the \texttt{nextInt} dispatch. The class \texttt{RunTimeKb} (generated by the \ide{}) is the run time knowledge base of the system; thus it is properly updated by calling the \textit{addSubject} (static) operation.

The getPortNum operation can be defined so to return a different port number at each call. However, since all the generated subjects share here the same virtual machine, the returned value can also be the same for all the filters.



%--------------------------------
\subsection{Filter pool}
%--------------------------------

If we want to associate to each new dynamically created filter a different computational node, we could introduce the idea of filter-pool managed by a \textit{filter-coordinator}.  When a new filter is required, a request can be sent to the filter-coordinator that selects a non-working  filter-resource and transmits as answer the name and the \texttt{IP}-port address of this resource.
Moreover, the filter-coordinator could also accept requests to the nodes of the network that intend to provide a new filter resource.

The specification (and implementation) of this kind of behavior is left to the reader. 


\newpage
%==============================================
\section{The sieve system with an user}
\labelsec{sieveUser}
%==============================================
 
Let us introduce here a new sieve system that includes an \textit{user} in which:

\begin{enumerate}
\item the user can ask the \texttt{sieve} for the element of a given position in the ordered sequence of prime numbers;
\item if no answer is received from \texttt{sieve} within an interval of time \texttt{DT} (e.g \texttt{DT=1sec}) , the user emit a \textit{stop} signal;
\item each component of the system terminates its activity as soon as the \texttt{stop} signal is emitted.
\end{enumerate}


The logical architecture of this new system can be expressed in \contact{} as follows:

\begin{Verbatim} [fontsize=\footnotesize,  frame=single, label=sieveSystem.contact: the components]
ContactSystem sieveSystem;
//1 - system components
Subject class FilterN ;

Subject intGen ;
Subject sieve ;
Subject filter2 inherits FilterN ;
Subject user ;
 
//2 - Message types
Dispatch nextInt ;      
Invitation newPrime ;        
Request getPrimeNum ; 
Signal stop ;

//3 - Communication patterns
sendIntToFilter2 : intGen forward  nextInt to filter2; 
intGenSense : intGen sense stop ;

recFilter2Int :  filter2 serve nextInt ; 				
sendIntToFilterN : FilterN forward  nextInt to FilterN;
recFilterNInt : FilterN serve nextInt; 
sendPrimeToSieve : FilterN ask newPrime to sieve; 		
filterNsense :  FilterN sense stop ; 

recNewprime : sieve accept newPrime support=TCP [host="localhost" port=8020];            
sieveSense: sieve sense stop ;
sieveGrant : sieve grant getPrimeNum ;

userDemand : user demand getPrimeNum to sieve ;
userEmit : user emit  stop  ;

//4 - Subject behavior specification
\end{Verbatim}

  

 
%------------------------------------
\subsubsection{Modelling application message content.\\}
\labelssec{distr3applmc1}
%------------------------------------

 
We suppose here that the application content of each message type is a data structure that can be represented as a \prolog{} term as follows (\texttt{N} denotes the representation of a natural number, \texttt{N>2}).


\begin{center}
\begin{tabular}{ | p{3,5 cm} |  p{2,5 cm} | p{4,5 cm} |}
\hline
Message & Content & Meaning\\
\hline
Invitation  \texttt{newPrime} & \texttt{prime(N)} & \texttt{N} is a prime number\\
\hline
Dispatch \texttt{nextInt} & \texttt{natural(n)} & \texttt{N} is a natural number \\
\hline
Request \texttt{getPrimeNum} & \texttt{getPrime(P)} & get the \texttt{P-th} prime\\
\hline
Signal \texttt{stop} & \texttt{stop()} & terminate the process \\
\hline
Answer   & \texttt{getPrime(P,N)} & answer to  \texttt{getPrime(P)} \\
\hline
\end{tabular}
\end{center}

%------------------------------------
\subsection{Workplan}
\labelssec{distr3wp}
%------------------------------------

\begin{itemize}
\item Define the application type \texttt{RequestForAPrime}.
\item Define a prototype by completing the specification of \xs{sieveUser} with the new behavior of each subject.
\end{itemize}


 
%==============================================
\section{The sieve with an observer}
\labelsec{sieveObserver}
%==============================================

TODO (At the moment read the code)

%==============================================
\section{Reliability of Local Message Sends}
\labelsec{}
%==============================================
From http://doc.akka.io/docs/akka/current/general/message-delivery-reliability.html.

The Akka test suite relies on not losing messages in the local context (and for non-error condition tests also for remote deployment), meaning that we actually do apply the best effort to keep our tests stable. A local tell operation can however fail for the same reasons as a normal method call can on the JVM:

StackOverflowError
OutOfMemoryError
other VirtualMachineError
In addition, local sends can fail in Akka-specific ways:

if the mailbox does not accept the message (e.g. full BoundedMailbox)
if the receiving actor fails while processing the message or is already terminated
While the first is clearly a matter of configuration the second deserves some thought: the sender of a message does not get feedback if there was an exception while processing, that notification goes to the supervisor instead. This is in general not distinguishable from a lost message for an outside observer.

You could register a shutdown hook like below and shutdown the akka system in it
\begin{verbatim}
Runtime.getRuntime().addShutdownHook(new Thread() {
            @Override
            public void run() {
                system.shutdown();
            }
        });
\end{verbatim}

Scalaz better than akka?

http://doc.akka.io/docs/akka/current/java/actors.html#Props

http://doc.akka.io/docs/akka/current/scala/dispatchers.html

\appendix

\bibliographystyle{abbrv}
\bibliography{../biblio}




\end{document} 
